import { set, Reaction } from "mobx";
import React, { useRef, useImperativeHandle, useEffect, memo, FC } from "react";

import {
  createCompositionContext,
  getCompositionContext,
  CompositionContext,
  setCompositionContext
} from "./context";
import { EMPTY_ARRAY, useForceUpdate, executeCallbacks } from "./utils";

export function initial<Props extends object, Rtn, Ref>(
  setup: (props: Props) => Rtn
) {
  return function useComposition(
    props: Props,
    ref?: React.RefObject<Ref>
  ): Rtn {
    const context = useRef<CompositionContext | undefined>();

    // 初始化
    if (context.current == null) {
      const ctx = (context.current = createCompositionContext(props));
      const prevCtx = getCompositionContext();
      setCompositionContext(ctx);
      ctx._instance = setup(ctx._props);
      setCompositionContext(prevCtx);
    }

    if (context.current._contexts.size && context.current._isMounted) {
      for (const { updater } of context.current._contexts.values()) {
        updater();
      }
    }

    if (ref && context.current._exposer != null) {
      // eslint-disable-next-line
      useImperativeHandle(ref, context.current._exposer, [
        context.current._exposer
      ]);
    }

    // 更新
    useEffect(() => {
      const ctx = context.current;
      if (ctx._isMounted) executeCallbacks(ctx._updater);
    });

    useEffect(() => {
      const ctx = context.current;
      ctx._isMounted = true;
      // 已挂载
      if (ctx._mounted.length) {
        ctx._mounted.forEach(cb => {
          const rt = cb();
          if (typeof rt === "function") {
            ctx.addDisposer(rt);
          }
        });
        ctx._mounted = EMPTY_ARRAY;
      }

      return () => executeCallbacks(ctx._disposers);
    }, []);

    // props 更新
    set(context.current._props, props);

    return context.current._instance!;
  };
}

/**
 * 创建组件
 */
export function createComponent<Props extends {}, Ref = void>(options: {
  setup: (props: Props) => () => React.ReactElement;
  name?: string;
  forwardRef?: boolean;
}): FC<Props> {
  const { setup, name, forwardRef } = options;
  const useComposition = initial(setup);

  const Comp = (props: Props, ref: React.RefObject<Ref>) => {
    const forceUpdate = useForceUpdate();
    const reactionRef = useRef<{
      reaction: Reaction;
      disposer: () => void;
    } | null>(null);

    const render = useComposition(props, forwardRef ? ref : null);

    if (reactionRef.current == null) {
      reactionRef.current = {
        reaction: new Reaction(`observer(${name || "Unknown"})`, () => {
          forceUpdate();
        }),
        disposer: () => {
          if (reactionRef.current && !reactionRef.current.reaction.isDisposed) {
            reactionRef.current.reaction.dispose();
            reactionRef.current = null;
          }
        }
      };
    }

    useEffect(() => {
      return () => {
        reactionRef.current && reactionRef.current.disposer();
      };
    }, []);

    let rendering;
    let error;
    reactionRef.current.reaction.track(() => {
      try {
        rendering = render();
      } catch (err) {
        error = err;
      }
    });

    if (error) {
      reactionRef.current.disposer();
      throw error;
    }

    return rendering;
  };

  Comp.displayName = `Composition(${name || "Unknown"})`;

  let finalComp;
  if (forwardRef) {
    finalComp = memo(React.forwardRef(Comp));
  } else {
    finalComp = memo(Comp);
  }

  finalComp.displayName = name;

  return finalComp;
}
